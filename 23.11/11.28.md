### 프로토콜지향프로그래밍(P.O.P)

하나의 클래스만 상속가능하고 기본적으로 상위클래스의 메모리 구조를 따라갈수 밖에 없고, 클래스에서만 가능하다는 클래스와 상속의 단점으로 애플에서 프로토콜이라는 것을 만들었다.

특징으로 여러 프로토콜 채택 가능하고, 메모리구조에 대한 특정요구사항이 없으며, 모든타입에 채택가능하며, 확장을 통해서 구체적 정의도 가능, 프로토콜을 타입으로 사용하여 활용성도 높일수 있고, 여러가지 프로토콜을 채택할 수 있어 구성도가 높고, 재사용성도 높다

### 프로토콜이란?

약속, 규약이라고도 하며 메서드, 프로퍼티, 기타 요구사항의 청사진(설계도)을 정의한다.

- 프로토콜은 타입이다.
    - 프로토콜을 이용해 타입을 정의하면 프로토콜을 구현하는 모든 class나 struct가 해당 프로토콜 타입을 수시하는 자리에 올 수 있다.
- 일급객체이다 - 다른객체들에 일반적으로 적용가능한 연산을 모두지원하는 객체
    - 런타임에 객체 생성이 가능
    - 데이터 구조안에 저장가능
    - 객체를 함수의 인자값으로 전달
    - 객체를 함수의 반환값으로
- 아래와 같은 조건이 일급객체와 일치한다.(공식문서)
    - 함수, 메서드 또는 이니셜라이저에서 매개변수 타입 또는 반환타입 사용
    - 상수, 변수 또는 속성 타입으로 사용
    - 배열, 딕셔너리 또는 기타 컨테이너의 타입으로 사용

### 프로토콜이 중요한 이유

객체의 유연한 설계를 위해서는 정의와 구현이 분리되어야 한다. OCP 원칙을 지키기 위해 정의와 구현을 분리해야한다.

OCP(Open Closed Principle): 확장에는 열려있고 변경에는 닫혀야 한다는 원칙

### 최소한의 요구사항

- 프로퍼티의 경우
    - var로 선언을 해야함
        
        반드시 get, set 키워드를 통해 읽기, 쓰기 여부를 결정
        
        채택한 경우에는 저장/ 계산 속성 모두 구현가능( let / var 가능)
        
        단, {get set}으로 지정한 경우 채택도 var로만 선언, 읽기,쓰기 모두 가능한 계산속성으로 구현해야함
        
    - static으로 타입프로퍼티 설정
        
        채택시 저장타입속성에서 static으로만 설정가능
        
        클래스에서 채택시 계산타입속성에서 static / class 모두구현가능
        
- 메서드의 경우
    - 메서드 헤드부분만 써준다.

- 생성자 구현(요구사항)
    - 채택할때 클래스는 생성자 앞에 required를 붙여야함(구조체는 필요없음)
        
        final로 선언되면 required 생략가능
        

- 서브스크립트(요구사항)
    - subscript라는 메서드가 존재(func 생략)
    - 읽기/쓰기 여부 설정
    - get만 써도됨

---

클래스 전용 프로토콜(AnyObject) - AnyObject는 프로토콜이다.

프로토콜에 AnyObject를 정의하면 클래스만 채택할 수 있다.

( AnyObject는 모든 클래스의 인스턴스도 표현할 수 있는 타입)

---

프로토콜 합성(프로토콜과 프로토콜 사이에 &를 넣어주면됨)

---

- 선택적 구현

@objc 프로토콜 앞에, @objc optional은 멤버앞에 추가

---

프로토콜 확장 - 기본구현제공

우선순위는 구현시 해당메서드, 없다면 그다음은 확장을 통한 기본메서드

원래 프로토콜에 메서드가 없는 확장을 통한 메서드는 타입에 따라 구현이 달라진다.

```swift
protocol Remote {
	func isOn()
	func isOff()
}

class TV: Remote {
	func isOn() {
		print("TV 켜기")
	}
	func isOff() {
		print("TV 끄기")
	}
	func doAnotherAction() {
			print("TV 또다른 동작")
		}
}

extension Remote {
	func isOn() {
		print("켜기")
	}
	func isOff() {
		print("끄기")
	}
	func doAnotherAction() {
		print("리모콘 또다른 동작")
	}
}

let tv = TV()
tv.isOn  //TV 켜기
tv.isOff  //TV 끄기
tv.doAnotherAction //TV 또다른 동작

let tv: Remote = TV()
tv.isOn  //TV 켜기
tv.isOff   //TV 끄기
tv.doAnotherAction //리모콘 또다른 동작
```

---

프로토콜 확장 제한도 가능

- extension 프로토콜 where Self: 특정프로토콜

특정프로토콜을 채택해야만 프로토콜의 기본구현이 가능하다라는 뜻
