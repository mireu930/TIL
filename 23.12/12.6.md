### 프로젝트

gitignore ?

- 로컬에선 유지하되 원격에선 삭제하고 싶을때

vi .gitignore → ## 이름 → / 파일의 이름 / → esc → ‘ctrl’ ‘:’ → wq →

git rm -r --cached 캐시 삭제

### 학습활동

구조체는 값타입의 데이터를 함수의 전달인자로 전달하면 메모리에 전달인자를 위한 인스턴스가 새로 생성된다. 생성된 새 인스턴스에는 전달하려는 값이 복사되어 들어간다.

클래스는 참조타입의 데이터는 전달인자로 전달할때 인스턴스의 참조를 전달하므로 새로운 인스턴스가 아닌 기존의 인스턴스 참조를 전달한다.

메서드 디스패치란?

메서드를 호출할 때, 현재 메모리에서 어떻게 각 메소드를 실행시키고 실행시킬지를 결정지을 때, 사용하는 것(?)


> 💡 디스패치
> - 함수를 컴파일 타임에 결정하냐, 런타임에 결정하냐에 따른 방식



스위프트가 함수를 실행시키는 방법

- 컴파일 타임시점에서 / Direct Dispatch(static) - 컴파일 시점에 코드 자체에 함수의 메모리 주소삽입 또는 함수의 명령코드를 해당위치에 코드 심음(인라인), 밸류타입에 사용, 상속.다형성의 장점을 누릴 수 없음
- 런타임시점에서 / Table Dispatch(dynamic) - 함수의 메모리주소를 배열형태 보관후 실행,  프로토콜.클래스에 사용(Virtual Table(클래스테이블), Witness Table(프로토콜테이블))
- 프로토콜 확장의 경우는 direct Dispatch로 동작 / 클래스의 확장 경우 direct Dispatch로 동작(상속시 재정의 불가), fianl키워드의 경우 direct Dispatch로 동작
- Message Dispatch - 상속구조를 모두 훑은 뒤 실행할 메서드 결정(objc)


> ❓ 강한참조에서 RC를 해제하지 못하면 메모리누수가 발생하게 되는데, 강한참조를 해제하지 못하는 경우는 무엇일까?
> - 객체와 객체가 서로 강한 참조를 하고 있을때 해당 인스턴스들은 메모리에서 해제가 되지 않는다.

그래서, 메모리 누수 방지를 위해 weak, unowned를 참조하여 해결할수 있다.
